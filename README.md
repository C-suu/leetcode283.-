# LeetCode 283.移动零

下面这题是 LeetCode「移动零」：**把数组里所有 0 挪到最后面**，同时**非零元素的相对顺序不变**，并且要求**原地操作（不新建一个新数组来装结果）**。

---

## 最推荐的解法：双指针（最少写入次数）

核心想法一句话：

> 用一个指针 `k` 记录“下一个应该放非零数的位置”，从左到右扫一遍，把非零数按顺序放到前面；最后把剩下的位置补 0。

### Python 代码（面试/刷题标准写法）

```python
from typing import List

class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        k = 0  # k 表示：下一个“非零数”应该放到的位置（索引）

        # 第一遍：把所有非零数按顺序挪到前面
        for i in range(len(nums)):  # i 从 0 到 len(nums)-1 逐个扫过去
            if nums[i] != 0:        # 如果当前位置不是 0
                nums[k] = nums[i]   # 把这个非零数放到前面的 nums[k]
                k += 1              # k 往后移动一格，准备放下一个非零数

        # 第二遍：把后面剩余的位置全部补成 0
        for i in range(k, len(nums)):  # 从 k 到末尾
            nums[i] = 0                # 这些位置都应该是 0
```

> 注意：函数返回 `None` 是正常的，因为题目要你**直接修改 nums 本身**。

---

## 给小白的“逐字逐句解释”（非常细）

### 1）这一行：`from typing import List`

```python
from typing import List
```

* 这是“类型提示”（可选，不影响运行）。
* `List[int]` 意思是：这是一个“整数列表”。
* 你不写也能过题，但写了更规范。

---

### 2）定义类和函数

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
```

* `class Solution:` 是 LeetCode 的固定写法。
* `def moveZeroes(...)` 定义函数名叫 `moveZeroes`。
* 参数 `nums` 就是题目给你的数组。
* `-> None` 表示不返回结果（因为直接修改 nums）。

---

### 3）关键变量 `k`

```python
k = 0
```

* `k` 是一个“位置指针”（也叫写指针）。
* 它永远指向：**下一个要放非零数字的位置**。
* 一开始当然从第 0 个位置开始放，所以 `k = 0`。

你可以把数组想成一排格子：

* `k` 指着“前面空着的格子”，准备往里塞非零数。

---

### 4）第一遍循环：从左到右扫一遍

```python
for i in range(len(nums)):
```

* `len(nums)` 是数组长度，比如 `[0,1,0,3,12]` 长度是 5。
* `range(5)` 会产生 `0,1,2,3,4`。
* 所以 `i` 会从 0 走到最后：逐个检查每个位置。

---

### 5）判断是不是 0

```python
if nums[i] != 0:
```

* `nums[i]` 是第 i 个元素。
* `!=` 是“不等于”。
* 所以这句意思是：**只处理非零数字**。

---

### 6）把非零数写到前面去

```python
nums[k] = nums[i]
```

这句非常关键：

* `nums[i]` 是我们扫描到的某个非零数。
* `nums[k]` 是我们想把它放到的“前面正确位置”。

也就是说：
**把这个非零数按顺序塞到数组前部。**

> 这一步不是“交换”，而是“写入覆盖”。
> 覆盖没关系，因为后面我们会统一补 0。

---

### 7）写完一个非零数，k 往后走

```python
k += 1
```

* `k += 1` 等价于 `k = k + 1`
* 意思是：下一个非零数应该放到下一个位置了。

---

### 8）第二遍循环：把剩余位置补 0

```python
for i in range(k, len(nums)):
    nums[i] = 0
```

当第一遍结束时：

* `[非零区]` 已经被填满了，长度就是 `k`
* 后面的区域应该全是 0

所以从 `k` 开始一直到数组末尾，全部写成 0。

---

## 用示例 1 走一遍（让你彻底“看见”它怎么动）

输入：

`nums = [0, 1, 0, 3, 12]`

初始：`k = 0`

### 第一遍扫描（i 从 0 到 4）

* i=0：nums[0]=0 → 是 0，不做事
  k=0，nums 不变

* i=1：nums[1]=1 → 非零
  nums[k]=nums[0]=1 → 把 1 写到 nums[0]
  数组变成 `[1, 1, 0, 3, 12]`
  k=1

* i=2：nums[2]=0 → 跳过
  k=1

* i=3：nums[3]=3 → 非零
  nums[1]=3
  数组变成 `[1, 3, 0, 3, 12]`
  k=2

* i=4：nums[4]=12 → 非零
  nums[2]=12
  数组变成 `[1, 3, 12, 3, 12]`
  k=3

第一遍结束：前 3 个位置已经是 `[1,3,12]`

### 第二遍补 0（i 从 k=3 到 4）

* i=3：nums[3]=0 → `[1, 3, 12, 0, 12]`
* i=4：nums[4]=0 → `[1, 3, 12, 0, 0]`

完成 ✅

---

## 为什么说它“尽量减少操作次数”？

很多人会写“遇到 0 就交换”，但交换会频繁移动元素，写入次数多。

这个做法的写入次数大概是：

* 非零元素写一次（共 `非零个数` 次）
* 末尾补 0 写一次（共 `零的个数` 次）
* 总写入次数 ≈ `n`（每个位置最多写一次）

这已经非常省操作了。

---

## 复杂度（你只需要记住结论）

* 时间：`O(n)`（只扫两遍，n 是数组长度）
* 空间：`O(1)`（只用了 k 这个变量，没有新数组）

---

## 把“每一步 i、k、nums 的变化”做成一张**Markdown 表格**，像调试日志一样给你看，会更直观。

下面给你**两个 Markdown 表格**：
1）示例 1：`[0,1,0,3,12]`
2）我自定义一个“自己的 nums”：`[4,0,5,0,0,3]`（更能看出变化）

我按我上面那份代码来走：**第一遍移动非零（for i...）**，**第二遍补 0（for i from k...）**。
表格里：

* `i`：当前扫描/写入的位置
* `k(操作前)`：本轮开始时 k 的值
* `nums[i]`：当前看到的值（第一遍才有意义；第二遍就是补 0）
* `动作`：这一轮做了什么
* `k(操作后)`：本轮结束后 k 的值
* `nums(本轮后)`：这一轮结束后的整个数组

---

## 表格 1：示例 1（nums = [0,1,0,3,12]）

### 第一遍：把非零按顺序写到前面

| 步骤 |  i | k(操作前) | nums[i] | 动作            | k(操作后) | nums(本轮后)         |
| -: | -: | -----: | ------: | ------------- | -----: | ----------------- |
|  1 |  0 |      0 |       0 | 是 0，跳过        |      0 | [0, 1, 0, 3, 12]  |
|  2 |  1 |      0 |       1 | 非零：nums[0]=1  |      1 | [1, 1, 0, 3, 12]  |
|  3 |  2 |      1 |       0 | 是 0，跳过        |      1 | [1, 1, 0, 3, 12]  |
|  4 |  3 |      1 |       3 | 非零：nums[1]=3  |      2 | [1, 3, 0, 3, 12]  |
|  5 |  4 |      2 |      12 | 非零：nums[2]=12 |      3 | [1, 3, 12, 3, 12] |

第一遍结束：`k = 3`，说明前 3 个位置已经放好了非零 `[1,3,12]`

### 第二遍：从 k 开始补 0

| 步骤 |  i | k(固定=3) | 动作        | nums(本轮后)         |
| -: | -: | ------: | --------- | ----------------- |
|  6 |  3 |       3 | nums[3]=0 | [1, 3, 12, 0, 12] |
|  7 |  4 |       3 | nums[4]=0 | [1, 3, 12, 0, 0]  |

✅ 最终结果：`[1,3,12,0,0]`

---

## 表格 2：我自己的 nums（nums = [4,0,5,0,0,3]）

### 第一遍：把非零按顺序写到前面

| 步骤 |  i | k(操作前) | nums[i] | 动作                   | k(操作后) | nums(本轮后)          |
| -: | -: | -----: | ------: | -------------------- | -----: | ------------------ |
|  1 |  0 |      0 |       4 | 非零：nums[0]=4（其实写回原位） |      1 | [4, 0, 5, 0, 0, 3] |
|  2 |  1 |      1 |       0 | 是 0，跳过               |      1 | [4, 0, 5, 0, 0, 3] |
|  3 |  2 |      1 |       5 | 非零：nums[1]=5         |      2 | [4, 5, 5, 0, 0, 3] |
|  4 |  3 |      2 |       0 | 是 0，跳过               |      2 | [4, 5, 5, 0, 0, 3] |
|  5 |  4 |      2 |       0 | 是 0，跳过               |      2 | [4, 5, 5, 0, 0, 3] |
|  6 |  5 |      2 |       3 | 非零：nums[2]=3         |      3 | [4, 5, 3, 0, 0, 3] |

第一遍结束：`k = 3`，前 3 个位置是非零 `[4,5,3]`

### 第二遍：从 k 开始补 0

| 步骤 |  i | k(固定=3) | 动作        | nums(本轮后)          |
| -: | -: | ------: | --------- | ------------------ |
|  7 |  3 |       3 | nums[3]=0 | [4, 5, 3, 0, 0, 3] |
|  8 |  4 |       3 | nums[4]=0 | [4, 5, 3, 0, 0, 3] |
|  9 |  5 |       3 | nums[5]=0 | [4, 5, 3, 0, 0, 0] |

✅ 最终结果：`[4,5,3,0,0,0]`

---

如果你把“你自己的 nums”（真实输入）发我，我也可以按你那组数据**再生成一份完全对应的表格**（每一步都严格对上你的数组）。

